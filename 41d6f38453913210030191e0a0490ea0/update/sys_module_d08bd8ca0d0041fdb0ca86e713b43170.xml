<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_module">
    <sys_module action="INSERT_OR_UPDATE">
        <content><![CDATA[var IncidentAnalysisUtils = Class.create();
IncidentAnalysisUtils.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {
  
  searchIncidents: function() {
    var searchTerm = this.getParameter('sysparm_search_term');
    
    gs.info('IncidentAnalysisUtils.searchIncidents called with term: ' + searchTerm);
    
    if (!searchTerm) {
      return JSON.stringify({
        success: false,
        error: 'Search term is required'
      });
    }

    try {
      var results = this._performIncidentSearch(searchTerm);
      gs.info('IncidentAnalysisUtils.searchIncidents found ' + results.length + ' results');
      return JSON.stringify({
        success: true,
        results: results
      });
    } catch (ex) {
      gs.error('IncidentAnalysisUtils.searchIncidents error: ' + ex.getMessage());
      return JSON.stringify({
        success: false,
        error: 'Search failed: ' + ex.getMessage()
      });
    }
  },

  _performIncidentSearch: function(searchTerm) {
    var results = [];
    var gr = new GlideRecord('incident');
    
    // Build query based on search term
    if (searchTerm.toUpperCase().indexOf('INC') === 0) {
      // Search by incident number
      gr.addQuery('number', 'CONTAINS', searchTerm);
    } else {
      // Search in multiple fields
      var qc = gr.addQuery('number', 'CONTAINS', searchTerm);
      qc.addOrCondition('short_description', 'CONTAINS', searchTerm);
      qc.addOrCondition('description', 'CONTAINS', searchTerm);
    }
    
    gr.orderByDesc('sys_updated_on');
    gr.setLimit(20);
    gr.query();

    gs.info('IncidentAnalysisUtils._performIncidentSearch query: ' + gr.getEncodedQuery());

    while (gr.next()) {
      var incident = {
        sys_id: gr.getUniqueValue(),
        number: gr.getDisplayValue('number'),
        short_description: gr.getDisplayValue('short_description'),
        state: gr.getValue('state'),
        state_display: gr.getDisplayValue('state'),
        priority: gr.getValue('priority'),
        priority_display: gr.getDisplayValue('priority'),
        assignment_group: gr.getValue('assignment_group'),
        assignment_group_display: gr.getDisplayValue('assignment_group'),
        opened_at: gr.getDisplayValue('opened_at'),
        caller_id_display: gr.getDisplayValue('caller_id')
      };
      results.push(incident);
    }

    return results;
  },

  generateIncidentAnalysis: function() {
    var sys_id = this.getParameter('sysparm_sys_id');
    
    if (!sys_id) {
      return JSON.stringify({
        success: false,
        error: 'sys_id parameter is required'
      });
    }

    try {
      // Get the incident record
      var incident = this._getIncidentRecord(sys_id);
      if (!incident) {
        return JSON.stringify({
          success: false,
          error: 'Incident not found'
        });
      }

      // Build timeline from multiple sources
      var timeline = this._buildTimeline(sys_id);
      
      // Generate debrief metrics
      var debrief = this._generateDebrief(incident, timeline);

      return JSON.stringify({
        success: true,
        incident: incident,
        timeline: timeline,
        debrief: debrief
      });
    } catch (ex) {
      gs.error('IncidentAnalysisUtils.generateIncidentAnalysis error: ' + ex.getMessage());
      return JSON.stringify({
        success: false,
        error: 'Analysis failed: ' + ex.getMessage()
      });
    }
  },

  _getIncidentRecord: function(sys_id) {
    var gr = new GlideRecord('incident');
    if (!gr.get(sys_id)) {
      return null;
    }

    return {
      sys_id: gr.getUniqueValue(),
      number: gr.getDisplayValue('number'),
      short_description: gr.getDisplayValue('short_description'),
      description: gr.getDisplayValue('description'),
      state: gr.getDisplayValue('state'),
      priority: gr.getDisplayValue('priority'),
      category: gr.getDisplayValue('category'),
      subcategory: gr.getDisplayValue('subcategory'),
      assigned_to: gr.getDisplayValue('assigned_to'),
      assignment_group: gr.getDisplayValue('assignment_group'),
      opened_by: gr.getDisplayValue('opened_by'),
      opened_at: gr.getDisplayValue('opened_at'),
      resolved_at: gr.getDisplayValue('resolved_at'),
      closed_at: gr.getDisplayValue('closed_at'),
      caller_id: gr.getDisplayValue('caller_id'),
      business_service: gr.getDisplayValue('business_service'),
      cmdb_ci: gr.getDisplayValue('cmdb_ci'),
      impact: gr.getDisplayValue('impact'),
      urgency: gr.getDisplayValue('urgency'),
      sys_created_on: gr.getDisplayValue('sys_created_on'),
      sys_updated_on: gr.getDisplayValue('sys_updated_on')
    };
  },

  _buildTimeline: function(sys_id) {
    var timeline = [];
    
    // Get journal entries (comments and work notes)
    timeline = timeline.concat(this._getJournalEntries(sys_id));
    
    // Get history entries (field changes)
    timeline = timeline.concat(this._getHistoryEntries(sys_id));
    
    // Sort all timeline events by timestamp
    timeline.sort(function(a, b) {
      var dateA = new GlideDateTime(a.timestamp);
      var dateB = new GlideDateTime(b.timestamp);
      return dateA.compareTo(dateB);
    });

    return timeline;
  },

  _getJournalEntries: function(sys_id) {
    var entries = [];
    var gr = new GlideRecord('sys_journal_field');
    gr.addQuery('element_id', sys_id);
    gr.addQuery('element', 'IN', 'comments,work_notes');
    gr.orderBy('sys_created_on');
    gr.query();

    while (gr.next()) {
      var entry = {
        type: gr.getValue('element') === 'comments' ? 'comment' : 'work_note',
        timestamp: gr.getDisplayValue('sys_created_on'),
        user: gr.getDisplayValue('sys_created_by'),
        content: gr.getDisplayValue('value'),
        element: gr.getValue('element')
      };
      entries.push(entry);
    }

    return entries;
  },

  _getHistoryEntries: function(sys_id) {
    var entries = [];
    var gr = new GlideRecord('sys_history_line');
    gr.addQuery('set.id', sys_id);
    gr.addQuery('field', 'IN', 'state,priority,assigned_to,assignment_group,category,subcategory');
    gr.orderBy('sys_created_on');
    gr.query();

    while (gr.next()) {
      var field = gr.getValue('field');
      var oldValue = gr.getDisplayValue('old_value');
      var newValue = gr.getDisplayValue('new_value');
      
      if (oldValue != newValue) { // Only include actual changes
        var entry = {
          type: 'field_change',
          timestamp: gr.getDisplayValue('sys_created_on'),
          user: gr.getDisplayValue('sys_created_by'),
          field: field,
          old_value: oldValue || '(empty)',
          new_value: newValue || '(empty)',
          change_description: this._formatFieldChange(field, oldValue, newValue)
        };
        entries.push(entry);
      }
    }

    return entries;
  },

  _formatFieldChange: function(field, oldValue, newValue) {
    var fieldNames = {
      'state': 'State',
      'priority': 'Priority', 
      'assigned_to': 'Assigned To',
      'assignment_group': 'Assignment Group',
      'category': 'Category',
      'subcategory': 'Subcategory'
    };
    
    var fieldName = fieldNames[field] || field;
    return fieldName + ' changed from "' + (oldValue || '(empty)') + '" to "' + (newValue || '(empty)') + '"';
  },

  _generateDebrief: function(incident, timeline) {
    var debrief = {
      resolution_time: this._calculateResolutionTime(incident),
      handoff_count: this._countHandoffs(timeline),
      groups_involved: this._getGroupsInvolved(timeline),
      note_count: this._countNotes(timeline),
      state_changes: this._countStateChanges(timeline),
      priority_changes: this._countPriorityChanges(timeline),
      cause_summary: this._generateCauseSummary(timeline),
      first_response_time: this._calculateFirstResponseTime(incident, timeline),
      key_events: this._identifyKeyEvents(timeline)
    };

    return debrief;
  },

  _calculateResolutionTime: function(incident) {
    if (!incident.opened_at) {
      return {
        value: 0,
        display: 'Unknown - no opening time'
      };
    }

    var openTime = new GlideDateTime(incident.opened_at);
    var resolveTime;
    
    if (incident.resolved_at) {
      resolveTime = new GlideDateTime(incident.resolved_at);
    } else if (incident.closed_at) {
      resolveTime = new GlideDateTime(incident.closed_at);
    } else {
      resolveTime = new GlideDateTime(); // Current time
    }

    var duration = GlideDateTime.subtract(openTime, resolveTime);
    var durationMS = duration.getNumericValue();
    
    return {
      value: Math.floor(durationMS / 1000), // seconds
      display: this._formatDuration(durationMS),
      is_resolved: !!incident.resolved_at
    };
  },

  _formatDuration: function(milliseconds) {
    var seconds = Math.floor(milliseconds / 1000);
    var minutes = Math.floor(seconds / 60);
    var hours = Math.floor(minutes / 60);
    var days = Math.floor(hours / 24);

    if (days > 0) {
      return days + ' days, ' + (hours % 24) + ' hours';
    } else if (hours > 0) {
      return hours + ' hours, ' + (minutes % 60) + ' minutes';
    } else if (minutes > 0) {
      return minutes + ' minutes';
    } else {
      return seconds + ' seconds';
    }
  },

  _countHandoffs: function(timeline) {
    var handoffs = 0;
    var assignmentChanges = timeline.filter(function(event) {
      return event.type === 'field_change' && 
             (event.field === 'assigned_to' || event.field === 'assignment_group');
    });
    
    return assignmentChanges.length;
  },

  _getGroupsInvolved: function(timeline) {
    var groups = [];
    
    timeline.forEach(function(event) {
      if (event.type === 'field_change' && event.field === 'assignment_group') {
        if (event.old_value && event.old_value !== '(empty)' && groups.indexOf(event.old_value) === -1) {
          groups.push(event.old_value);
        }
        if (event.new_value && event.new_value !== '(empty)' && groups.indexOf(event.new_value) === -1) {
          groups.push(event.new_value);
        }
      }
    });

    return groups;
  },

  _countNotes: function(timeline) {
    var counts = {
      comments: 0,
      work_notes: 0,
      total: 0
    };

    timeline.forEach(function(event) {
      if (event.type === 'comment') {
        counts.comments++;
        counts.total++;
      } else if (event.type === 'work_note') {
        counts.work_notes++;
        counts.total++;
      }
    });

    return counts;
  },

  _countStateChanges: function(timeline) {
    return timeline.filter(function(event) {
      return event.type === 'field_change' && event.field === 'state';
    }).length;
  },

  _countPriorityChanges: function(timeline) {
    return timeline.filter(function(event) {
      return event.type === 'field_change' && event.field === 'priority';
    }).length;
  },

  _generateCauseSummary: function(timeline) {
    // Find earliest journal entry that might contain cause information
    var journalEntries = timeline.filter(function(event) {
      return (event.type === 'comment' || event.type === 'work_note') && 
             event.content && event.content.length > 10;
    });

    if (journalEntries.length === 0) {
      return 'No detailed information available in journal entries';
    }

    var firstEntry = journalEntries[0];
    var content = firstEntry.content.toLowerCase();
    
    // Simple keyword-based cause detection
    if (content.indexOf('network') !== -1 || content.indexOf('connectivity') !== -1) {
      return 'Network or connectivity related issue';
    } else if (content.indexOf('server') !== -1 || content.indexOf('system') !== -1 || content.indexOf('down') !== -1) {
      return 'Server or system related issue';
    } else if (content.indexOf('application') !== -1 || content.indexOf('software') !== -1) {
      return 'Application or software related issue';
    } else if (content.indexOf('user') !== -1 || content.indexOf('access') !== -1 || content.indexOf('login') !== -1) {
      return 'User access or authentication issue';
    } else if (content.indexOf('performance') !== -1 || content.indexOf('slow') !== -1) {
      return 'Performance related issue';
    } else if (content.indexOf('hardware') !== -1 || content.indexOf('disk') !== -1 || content.indexOf('memory') !== -1) {
      return 'Hardware related issue';
    } else {
      // Return first 100 characters of the earliest entry as a fallback
      var summary = firstEntry.content.substring(0, 100);
      if (firstEntry.content.length > 100) {
        summary += '...';
      }
      return 'Issue described as: ' + summary;
    }
  },

  _calculateFirstResponseTime: function(incident, timeline) {
    if (!incident.opened_at) {
      return {
        value: 0,
        display: 'Unknown - no opening time'
      };
    }

    var openTime = new GlideDateTime(incident.opened_at);
    var firstResponseTime = null;

    // Find first comment or work note after incident creation
    var responses = timeline.filter(function(event) {
      return (event.type === 'comment' || event.type === 'work_note') && 
             event.user !== incident.opened_by;
    });

    if (responses.length > 0) {
      firstResponseTime = new GlideDateTime(responses[0].timestamp);
      var duration = GlideDateTime.subtract(openTime, firstResponseTime);
      var durationMS = duration.getNumericValue();
      
      return {
        value: Math.floor(durationMS / 1000),
        display: this._formatDuration(durationMS),
        response_by: responses[0].user
      };
    } else {
      return {
        value: 0,
        display: 'No response recorded',
        response_by: null
      };
    }
  },

  _identifyKeyEvents: function(timeline) {
    var keyEvents = [];
    
    timeline.forEach(function(event) {
      if (event.type === 'field_change') {
        if (event.field === 'state' || 
            event.field === 'priority' || 
            event.field === 'assigned_to' || 
            event.field === 'assignment_group') {
          keyEvents.push({
            timestamp: event.timestamp,
            description: event.change_description,
            user: event.user,
            significance: 'high'
          });
        }
      } else if (event.type === 'comment' || event.type === 'work_note') {
        // Mark as key event if it's a substantial note (>50 chars)
        if (event.content && event.content.length > 50) {
          keyEvents.push({
            timestamp: event.timestamp,
            description: event.type === 'comment' ? 'Comment added' : 'Work note added',
            user: event.user,
            significance: 'medium',
            content_preview: event.content.substring(0, 80) + (event.content.length > 80 ? '...' : '')
          });
        }
      }
    });

    return keyEvents;
  },

  type: 'IncidentAnalysisUtils'
});]]></content>
        <external_source>false</external_source>
        <path>x_1118332_incident/x-1118332-incident-deb/1.0.0/src/server/script-includes/IncidentAnalysisUtils.js</path>
        <sys_class_name>sys_module</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-11-14 14:29:37</sys_created_on>
        <sys_id>d08bd8ca0d0041fdb0ca86e713b43170</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>x_1118332_incident/x-1118332-incident-deb/1.0.0/src/server/script-includes/IncidentAnalysisUtils.js</sys_name>
        <sys_package display_value="Incident Deb" source="x_1118332_incident">41d6f38453913210030191e0a0490ea0</sys_package>
        <sys_policy/>
        <sys_scope display_value="Incident Deb">41d6f38453913210030191e0a0490ea0</sys_scope>
        <sys_update_name>sys_module_d08bd8ca0d0041fdb0ca86e713b43170</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-11-14 14:29:37</sys_updated_on>
    </sys_module>
</record_update>
